/**
*  Copyright 2019 Adobe Systems Incorporated. All rights reserved.
*  This file is licensed to you under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License. You may obtain a copy
*  of the License at http://www.apache.org/licenses/LICENSE-2.0
*
*  Unless required by applicable law or agreed to in writing, software distributed under
*  the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
*  OF ANY KIND, either express or implied. See the License for the specific language
*  governing permissions and limitations under the License.
*
*
**/


/* 
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace AdobeSign.Rest.Model.Agreements
{
    /// <summary>
    /// ParticipantSetInfo
    /// </summary>
    [DataContract]
    public partial class ParticipantSetInfo :  IEquatable<ParticipantSetInfo>, IValidatableObject
    {
        /// <summary>
        /// Role assumed by all participants in the set (signer, approver etc.)
        /// </summary>
        /// <value>Role assumed by all participants in the set (signer, approver etc.)</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RoleEnum
        {
            
            /// <summary>
            /// Enum SIGNER for value: SIGNER
            /// </summary>
            [EnumMember(Value = "SIGNER")]
            SIGNER = 1,
            
            /// <summary>
            /// Enum APPROVER for value: APPROVER
            /// </summary>
            [EnumMember(Value = "APPROVER")]
            APPROVER = 2,
            
            /// <summary>
            /// Enum ACCEPTOR for value: ACCEPTOR
            /// </summary>
            [EnumMember(Value = "ACCEPTOR")]
            ACCEPTOR = 3,
            
            /// <summary>
            /// Enum CERTIFIEDRECIPIENT for value: CERTIFIED_RECIPIENT
            /// </summary>
            [EnumMember(Value = "CERTIFIED_RECIPIENT")]
            CERTIFIEDRECIPIENT = 4,
            
            /// <summary>
            /// Enum FORMFILLER for value: FORM_FILLER
            /// </summary>
            [EnumMember(Value = "FORM_FILLER")]
            FORMFILLER = 5,
            
            /// <summary>
            /// Enum DELEGATETOSIGNER for value: DELEGATE_TO_SIGNER
            /// </summary>
            [EnumMember(Value = "DELEGATE_TO_SIGNER")]
            DELEGATETOSIGNER = 6,
            
            /// <summary>
            /// Enum DELEGATETOAPPROVER for value: DELEGATE_TO_APPROVER
            /// </summary>
            [EnumMember(Value = "DELEGATE_TO_APPROVER")]
            DELEGATETOAPPROVER = 7,
            
            /// <summary>
            /// Enum DELEGATETOACCEPTOR for value: DELEGATE_TO_ACCEPTOR
            /// </summary>
            [EnumMember(Value = "DELEGATE_TO_ACCEPTOR")]
            DELEGATETOACCEPTOR = 8,
            
            /// <summary>
            /// Enum DELEGATETOCERTIFIEDRECIPIENT for value: DELEGATE_TO_CERTIFIED_RECIPIENT
            /// </summary>
            [EnumMember(Value = "DELEGATE_TO_CERTIFIED_RECIPIENT")]
            DELEGATETOCERTIFIEDRECIPIENT = 9,
            
            /// <summary>
            /// Enum DELEGATETOFORMFILLER for value: DELEGATE_TO_FORM_FILLER
            /// </summary>
            [EnumMember(Value = "DELEGATE_TO_FORM_FILLER")]
            DELEGATETOFORMFILLER = 10,
            
            /// <summary>
            /// Enum SHARE for value: SHARE
            /// </summary>
            [EnumMember(Value = "SHARE")]
            SHARE = 11
        }

        /// <summary>
        /// Role assumed by all participants in the set (signer, approver etc.)
        /// </summary>
        /// <value>Role assumed by all participants in the set (signer, approver etc.)</value>
        [DataMember(Name="role", EmitDefaultValue=false)]
        public RoleEnum? Role { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="ParticipantSetInfo" /> class.
        /// </summary>
        /// <param name="Label">The unique label of a participant set.&lt;br&gt;For custom workflows, label specified in the participation set should map it to the participation step in the custom workflow..</param>
        /// <param name="MemberInfos">Array of ParticipantInfo objects, containing participant-specific data (e.g. email). All participants in the array belong to the same set.</param>
        /// <param name="Name">Name of the participant set (it can be empty, but needs not to be unique in a single agreement). Maximum no of characters in participant set name is restricted to 255.</param>
        /// <param name="Order">Index indicating position at which signing group needs to sign. Signing group to sign at first place is assigned a 1 index. Different signingOrder specified in input should form a valid consecutive increasing sequence of integers. Otherwise signingOrder will be considered invalid. No signingOrder should be specified for SHARE role.</param>
        /// <param name="PrivateMessage">Participant set&#39;s private message - all participants in the set will receive the same message.</param>
        /// <param name="Role">Role assumed by all participants in the set (signer, approver etc.).</param>
        /// <param name="VisiblePages">When you enable limited document visibility (documentVisibilityEnabled), you can specify which file (fileInfo) should be made visible to which specific participant set.&lt;br&gt;Specify one or more label values of a fileInfos element.&lt;br&gt;Each signer participant sets must contain at least one required signature field in at least one visible file included in this API call; if not a page with a signature field is automatically appended for any missing participant sets. If there is a possibility that one or more participant sets do not have a required signature field in the files included in the API call, all signer participant sets should include a special index value of &#39;0&#39; to make this automatically appended signature page visible to the signer. Not doing so may result in an error. For all other roles, you may omit this value to exclude this page..</param>
        public ParticipantSetInfo(string Label = default(string), List<ParticipantSetMemberInfo> MemberInfos = default(List<ParticipantSetMemberInfo>), string Name = default(string), int? Order = default(int?), string PrivateMessage = default(string), RoleEnum? Role = default(RoleEnum?), List<string> VisiblePages = default(List<string>))
        {
            this.Label = Label;
            this.MemberInfos = MemberInfos;
            this.Name = Name;
            this.Order = Order;
            this.PrivateMessage = PrivateMessage;
            this.Role = Role;
            this.VisiblePages = VisiblePages;
        }
        
        /// <summary>
        /// The unique label of a participant set.&lt;br&gt;For custom workflows, label specified in the participation set should map it to the participation step in the custom workflow.
        /// </summary>
        /// <value>The unique label of a participant set.&lt;br&gt;For custom workflows, label specified in the participation set should map it to the participation step in the custom workflow.</value>
        [DataMember(Name="label", EmitDefaultValue=false)]
        public string Label { get; set; }

        /// <summary>
        /// Array of ParticipantInfo objects, containing participant-specific data (e.g. email). All participants in the array belong to the same set
        /// </summary>
        /// <value>Array of ParticipantInfo objects, containing participant-specific data (e.g. email). All participants in the array belong to the same set</value>
        [DataMember(Name="memberInfos", EmitDefaultValue=false)]
        public List<ParticipantSetMemberInfo> MemberInfos { get; set; }

        /// <summary>
        /// Name of the participant set (it can be empty, but needs not to be unique in a single agreement). Maximum no of characters in participant set name is restricted to 255
        /// </summary>
        /// <value>Name of the participant set (it can be empty, but needs not to be unique in a single agreement). Maximum no of characters in participant set name is restricted to 255</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// Index indicating position at which signing group needs to sign. Signing group to sign at first place is assigned a 1 index. Different signingOrder specified in input should form a valid consecutive increasing sequence of integers. Otherwise signingOrder will be considered invalid. No signingOrder should be specified for SHARE role
        /// </summary>
        /// <value>Index indicating position at which signing group needs to sign. Signing group to sign at first place is assigned a 1 index. Different signingOrder specified in input should form a valid consecutive increasing sequence of integers. Otherwise signingOrder will be considered invalid. No signingOrder should be specified for SHARE role</value>
        [DataMember(Name="order", EmitDefaultValue=false)]
        public int? Order { get; set; }

        /// <summary>
        /// Participant set&#39;s private message - all participants in the set will receive the same message
        /// </summary>
        /// <value>Participant set&#39;s private message - all participants in the set will receive the same message</value>
        [DataMember(Name="privateMessage", EmitDefaultValue=false)]
        public string PrivateMessage { get; set; }


        /// <summary>
        /// When you enable limited document visibility (documentVisibilityEnabled), you can specify which file (fileInfo) should be made visible to which specific participant set.&lt;br&gt;Specify one or more label values of a fileInfos element.&lt;br&gt;Each signer participant sets must contain at least one required signature field in at least one visible file included in this API call; if not a page with a signature field is automatically appended for any missing participant sets. If there is a possibility that one or more participant sets do not have a required signature field in the files included in the API call, all signer participant sets should include a special index value of &#39;0&#39; to make this automatically appended signature page visible to the signer. Not doing so may result in an error. For all other roles, you may omit this value to exclude this page.
        /// </summary>
        /// <value>When you enable limited document visibility (documentVisibilityEnabled), you can specify which file (fileInfo) should be made visible to which specific participant set.&lt;br&gt;Specify one or more label values of a fileInfos element.&lt;br&gt;Each signer participant sets must contain at least one required signature field in at least one visible file included in this API call; if not a page with a signature field is automatically appended for any missing participant sets. If there is a possibility that one or more participant sets do not have a required signature field in the files included in the API call, all signer participant sets should include a special index value of &#39;0&#39; to make this automatically appended signature page visible to the signer. Not doing so may result in an error. For all other roles, you may omit this value to exclude this page.</value>
        [DataMember(Name="visiblePages", EmitDefaultValue=false)]
        public List<string> VisiblePages { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ParticipantSetInfo {\n");
            sb.Append("  Label: ").Append(Label).Append("\n");
            sb.Append("  MemberInfos: ").Append(MemberInfos).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Order: ").Append(Order).Append("\n");
            sb.Append("  PrivateMessage: ").Append(PrivateMessage).Append("\n");
            sb.Append("  Role: ").Append(Role).Append("\n");
            sb.Append("  VisiblePages: ").Append(VisiblePages).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ParticipantSetInfo);
        }

        /// <summary>
        /// Returns true if ParticipantSetInfo instances are equal
        /// </summary>
        /// <param name="input">Instance of ParticipantSetInfo to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ParticipantSetInfo input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Label == input.Label ||
                    (this.Label != null &&
                    this.Label.Equals(input.Label))
                ) && 
                (
                    this.MemberInfos == input.MemberInfos ||
                    this.MemberInfos != null &&
                    this.MemberInfos.SequenceEqual(input.MemberInfos)
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Order == input.Order ||
                    (this.Order != null &&
                    this.Order.Equals(input.Order))
                ) && 
                (
                    this.PrivateMessage == input.PrivateMessage ||
                    (this.PrivateMessage != null &&
                    this.PrivateMessage.Equals(input.PrivateMessage))
                ) && 
                (
                    this.Role == input.Role ||
                    (this.Role != null &&
                    this.Role.Equals(input.Role))
                ) && 
                (
                    this.VisiblePages == input.VisiblePages ||
                    this.VisiblePages != null &&
                    this.VisiblePages.SequenceEqual(input.VisiblePages)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Label != null)
                    hashCode = hashCode * 59 + this.Label.GetHashCode();
                if (this.MemberInfos != null)
                    hashCode = hashCode * 59 + this.MemberInfos.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.Order != null)
                    hashCode = hashCode * 59 + this.Order.GetHashCode();
                if (this.PrivateMessage != null)
                    hashCode = hashCode * 59 + this.PrivateMessage.GetHashCode();
                if (this.Role != null)
                    hashCode = hashCode * 59 + this.Role.GetHashCode();
                if (this.VisiblePages != null)
                    hashCode = hashCode * 59 + this.VisiblePages.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

}
